using System.Collections;
using System.Collections.Generic;
using UnityEngine;


public class ControlAllocator : MonoBehaviour
{
// [f, phir, thetar] = controlAllocator1(fx, fy, fz, psir, phirMax,
// thetarMax) implements a control allocator that computes roll and pitch
// references phir and thetar along with the vertical force generated by the/
// propellers to attain a desired force vector [fx, fy, fz]^T. 

// The inputs are:
    // fx: x component of the desired force.
    // fy: y component of the desired force.
    // fz: z component of the desired force.
    // psir: reference yaw angle.
    // phirMax: phir is saturated to stay within [-phirMax, phirMax].
    // thetarMax: thetar is saturated to stay within [-thetarMax, thetarMax].

// Outputs are:
    // f: magnitude of the desired force.
    // phir: roll reference.
    // thetar: pitch reference.

    private Rigidbody droneRb;
    private PositionController positionController;
    private Rigidbody forceReferenceRb;
    public Vector3 force;
    public float psiR;
    public float psiAngle;
    public float phiR;
    public float thetaR;
    public float angleMax = 30f;
    private float upperLimit;
    private float lowerLimit;
    public float forceNorm;
    public float phirMax; // roll max
    public float thetarMax; // pitch max

    public Vector3 forceField;

    public float setPoint; // used to test the att controller
    // Start is called before the first frame update
    void Start()
    {
        droneRb = GetComponent<Rigidbody>();
        positionController = GetComponent<PositionController>();

        // converts limits to radians
        upperLimit =   angleMax  * Mathf.PI  / 180 ;
        lowerLimit = - angleMax  * Mathf.PI  / 180 ; 
        // converts limits to radians
        phirMax   = angleMax  * Mathf.PI  / 180 ;
        thetarMax = angleMax  * Mathf.PI  / 180 ;

    }

    // Update is called once per frame
    void Update() 
    {
        upperLimit =   angleMax  * Mathf.PI  / 180 ;
        lowerLimit = - angleMax  * Mathf.PI  / 180 ; 
        // converts limits to radians
        phirMax   = angleMax  * Mathf.PI  / 180 ;
        thetarMax = angleMax  * Mathf.PI  / 180 ;



    }

    void FixedUpdate() {
        // update force 

        force = positionController.forceVector + forceField;
        forceNorm = force.magnitude;

        float nx = force.x / forceNorm ;
        float ny = force.y / forceNorm ;
        float nz = force.z / forceNorm ;

        Vector3 localForce = transform.InverseTransformVector(force);
        //Debug.Log("localForce: " + localForce + " force: " + force);

        // compute roll and pitch references

        thetaR = nz  ;
        thetaR = localForce.z / forceNorm; 
        thetaR = Mathf.Asin( (localForce.z / forceNorm) / Mathf.Cos(psiR));
        //thetaR = Mathf.Atan2(nx * Mathf.Cos(psiR) + nz * Mathf.Sin(psiR) , ny ) ;

        phiR = - nx;
        phiR = - localForce.x/ forceNorm ;
        //float A = Mathf.Sin(psiR) * Mathf.Sin(thetaR) ;
       // phiR = Mathf.Asin( (A * ny) - nx * Mathf.Cos(thetaR)/ (A*A + Mathf.Cos(thetaR)*Mathf.Cos(thetaR)   )  );

        // saturate roll and pitch references   
        phiR   = Mathf.Clamp(phiR,   lowerLimit, upperLimit);
        thetaR = Mathf.Clamp(thetaR, lowerLimit, upperLimit);


        psiR = psiAngle * Mathf.PI / 180;

        //Debug.Log("phiR: " + phiR + " thetaR: " + thetaR + " psiR: " + psiR);

        // to test the attitude controller implementation
        //thetaR = (setPoint ) * Mathf.PI / 180 ;
        //phiR   = setPoint * Mathf.PI / 180;

    }

    float LimitAngle(float angle, float maxAngle, float minAngle) {
        if (angle > maxAngle) {
            angle = maxAngle;
        }
        if (angle < minAngle) {
            angle = minAngle;
        }
        return angle;
    }

    public void UpdateForceField(Vector3 force) {
        this.forceField = force;
    }
    
}
